<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (d3-cloud, seeded)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root {
    --base-size: clamp(18px, 2.2vw, 36px); /* uniform end size */
  }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
  .word.new { transform-origin: center center; transform-box: fill-box; animation: pop 3.6s ease-out both; }
  @keyframes pop { 0% { transform: scale(2.1); opacity: 0; } 10% { opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  // deterministic PRNG (mulberry32)
  function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t ^ t>>>15, t | 1);t^=t+Math.imul(t ^ t>>>7, t | 61);return ((t ^ t>>>14) >>> 0) / 4294967296;};}
  const BASE_SEED = 0xDEC0AD; // constant seed so earlier words stay put when new ones are appended

  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    svg.attr('viewBox', `0 0 ${W} ${H}`);
    layout(); // reflow to fit size; on same seed/order earlier words stay consistent for same size
  }
  window.addEventListener('resize', resize);

  function load() {
    try { return JSON.parse(localStorage.getItem(KEY)) || []; }
    catch { return []; }
  }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function getWords() {
    const list = load();
    // Keep a stable order: by addedAt ascending (then name) so appending donors doesn't reorder earlier ones
    const ordered = list.slice().sort((a,b) => (a.addedAt - b.addedAt) || a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const baseSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    return ordered.map(d => ({ text: d.name, key: keyName(d.name), size: baseSizePx }));
  }

  let lastSet = new Set(); // keys present in previous draw

  function layout(newNameSet = new Set()) {
    const words = getWords();
    // New names are those not in lastSet
    if (!newNameSet.size) {
      newNameSet = new Set(words.filter(w => !lastSet.has(w.key)).map(w => w.key));
    }

    const random = mulberry32(BASE_SEED); // same seed every time
    const cloud = d3.layout.cloud()
      .size([W, H])
      .words(words)
      .padding(4)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0)
      .random(random)
      .spiral('archimedean')
      .on('end', draw);

    cloud.start();

    function draw(wds) {
      const CENTERX = W/2, CENTERY = H/2;

      const g = svg.selectAll('g.words').data([null]);
      g.enter().append('g').attr('class','words');
      const layer = svg.select('g.words');

      const sel = layer.selectAll('text.word').data(wds, d => d.text);

      sel.exit().remove();

      const enter = sel.enter().append('text')
        .attr('class', d => 'word' + (newNameSet.has(d.key) ? ' new' : ''))
        .style('font-family', 'system-ui, sans-serif')
        .text(d => d.text)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('transform', `translate(${CENTERX},${CENTERY})`)
        .style('opacity', 0);

      enter.merge(sel)
        .transition()
        .duration(1000)
        .attr('transform', d => `translate(${d.x + CENTERX},${d.y + CENTERY}) rotate(${d.rotate || 0})`)
        .style('opacity', 1)
        .attr('font-size', d => d.size);

      // update lastSet
      lastSet = new Set(words.map(w => w.key));
    }
  }

  function fullRender() {
    // Initial draw; mark all as existing (no pop)
    const words = getWords();
    lastSet = new Set(words.map(w => w.key));
    layout(/*newNameSet*/ new Set()); // none new
  }

  function addNew(donors) {
    // Simply re-layout with same seed and same stable ordering;
    // earlier words will keep positions and only new ones will appear.
    const newSet = new Set(donors.map(d => keyName(d.name)));
    layout(newSet);
  }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) addNew(msg.donors);
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      lastSet = new Set();
      fullRender();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) fullRender(); });

  // Boot
  resize();
  fullRender();
})();
</script>
</body>
</html>