<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (spacing + scaling)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
  .word.emph { font-weight: 700; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function resize(){ W = stage.clientWidth; H = stage.clientHeight; setViewBox(); redraw(); }
  window.addEventListener('resize', resize);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  // font scaling past 50 names
  function baseScaleForCount(n){
    if (n <= 50) return 1;
    // linearly drop to 0.65 by 250 names
    const m = 1 - (n - 50) * ((1 - 0.65) / 200);
    return Math.max(0.65, m);
  }

  function wordsFromDonors() {
    const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    const list = load().slice().sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const scale = baseScaleForCount(list.length);
    const size = cssSize * scale;
    return list.map(d => ({ text: d.name, key: keyName(d.name), size }));
  }

  let prevPos = new Map();
  const emphasized = new Set();

  function dynamicPadding(d) {
    // heavier vertical padding to discourage stacking
    const base = Math.max(12, Math.round(d.size * 0.4));
    const extra = Math.min(30, Math.floor(d.text.length * 0.8));
    return base + extra;
  }

  function hiDpiCanvas() {
    const ratio = (window.devicePixelRatio || 1);
    const c = document.createElement('canvas');
    c.width = Math.round(256 * ratio);
    c.height = Math.round(256 * ratio);
    const ctx = c.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return c;
  }

  // Stronger vertical relaxation: prioritize separating on Y, ensure min row gap
  function relaxPositions(nextPos) {
    const keys = Array.from(nextPos.keys());
    const nodes = keys.map(k => ({ key: k, ...nextPos.get(k) }));
    const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;

    // Estimate bbox
    nodes.forEach(n => {
      const textLen = Math.max(6, n.key.length);
      n.w = Math.max(40, textLen * size * 0.6) + 10;
      n.h = size * 1.6 + 10; // taller line box
    });

    const passes = 4;
    const pushX = 3, pushY = 10;
    const minRowGap = 6;

    for (let p=0; p<passes; p++) {
      for (let i=0; i<nodes.length; i++) {
        for (let j=i+1; j<nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const overlapX = Math.abs(a.x-b.x) < (a.w+b.w)/2;
          const overlapY = Math.abs(a.y-b.y) < (a.h+b.h)/2;
          if (overlapX && overlapY) {
            // prefer vertical push
            const sign = (a.y <= b.y) ? -1 : 1;
            a.y += sign * pushY;
            b.y -= sign * pushY;
            // slight horizontal nudge to avoid perfect vertical stacking
            const hSign = (a.x <= b.x) ? -1 : 1;
            a.x += hSign * pushX;
            b.x -= hSign * pushX;
            // clamp
            a.x = Math.max(a.w/2, Math.min(W - a.w/2, a.x));
            b.x = Math.max(b.w/2, Math.min(W - b.w/2, b.x));
            a.y = Math.max(a.h/2, Math.min(H - a.h/2, a.y));
            b.y = Math.max(b.h/2, Math.min(H - b.h/2, b.y));
          } else if (overlapX && !overlapY) {
            // enforce min vertical spacing
            const dy = Math.abs(a.y - b.y);
            if (dy < minRowGap) {
              const sgn = (a.y < b.y) ? -1 : 1;
              a.y += sgn * (minRowGap - dy)/2;
              b.y -= sgn * (minRowGap - dy)/2;
            }
          }
        }
      }
    }

    nodes.forEach(n => nextPos.set(n.key, { x:n.x, y:n.y, rotate:n.rotate||0, size:n.size }));
    return nextPos;
  }

  function toggleEmphasize(nameKey){
    const node = svg.selectAll('text.word').filter(function(){ return this.textContent && nameKey === keyName(this.textContent); });
    if (!node.size()) return;
    if (emphasized.has(nameKey)) {
      emphasized.delete(nameKey);
      node.classed('emph', false).transition().duration(300)
        .attr('transform', () => {
          const p = prevPos.get(nameKey);
          return 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(1)';
        });
    } else {
      emphasized.add(nameKey);
      node.each(function(){ this.parentNode.appendChild(this); });
      node.classed('emph', true).transition().duration(300)
        .attr('transform', () => {
          const p = prevPos.get(nameKey);
          return 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(1.35)';
        });
    }
  }

  function redraw() {
    const CENTERX = W/2, CENTERY = H/2;
    const words = wordsFromDonors();
    const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
    const streamed = new Set();

    const cloud = d3.layout.cloud()
      .canvas(hiDpiCanvas)
      .size([W, H])
      .words(words)
      .padding(dynamicPadding)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0)
      .timeInterval(10)
      .on('word', d => {
        const k = keyName(d.text);
        if (streamed.has(k)) return;
        streamed.add(k);
        const pos = { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size };

        let node = layer.selectAll('text.word').filter(function(){ return this.textContent === d.text; });
        if (!node.size()) {
          node = layer.append('text')
            .attr('class', 'word')
            .style('font-family', 'system-ui, sans-serif')
            .text(d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', d.size)
            .attr('transform', 'translate(' + (CENTERX) + ',' + (CENTERY) + ') rotate(0)');
        }
        node.transition().duration(400)
          .style('opacity', 1)
          .attr('font-size', d.size)
          .attr('transform', 'translate(' + pos.x + ',' + pos.y + ') rotate(' + pos.rotate + ')');
      })
      .on('end', placed => {
        let nextPos = new Map();
        placed.forEach(d => nextPos.set(keyName(d.text), { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

        // Relax positions for vertical separation
        nextPos = relaxPositions(nextPos);

        const sel = layer.selectAll('text.word').data(placed, function(d){ return d ? d.text : this.textContent; });

        sel.exit().transition().duration(300).style('opacity', 0).remove();

        const enter = sel.enter().append('text')
          .attr('class', 'word')
          .style('font-family', 'system-ui, sans-serif')
          .text(d => d.text)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('opacity', 0)
          .attr('font-size', d => d.size)
          .attr('transform', 'translate(' + (CENTERX) + ',' + (CENTERY) + ')');

        enter.merge(sel)
          .classed('emph', function(d){ return emphasized.has(keyName(d.text)); })
          .transition().duration(600)
          .style('opacity', 1)
          .attr('font-size', d => d.size)
          .attr('transform', d => {
            const p = nextPos.get(keyName(d.text));
            const scale = emphasized.has(keyName(d.text)) ? 1.35 : 1;
            return 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(' + scale + ')';
          });

        prevPos = nextPos;
      });

    cloud.start();
  }

  function fullRender() { prevPos.clear(); redraw(); }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) redraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      fullRender();
    }
    else if (msg.type === 'emphasize' && msg.name) {
      toggleEmphasize(keyName(msg.name));
    }
    else if (msg.type === 'remove' && msg.key) {
      redraw();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) redraw(); });

  setViewBox();
  fullRender();
})();
</script>
</body>
</html>