<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (debug count)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { fill:#111; dominant-baseline: middle; text-anchor: middle; }
  .word.emph { font-weight: 700; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const EMPH_KEY = 'donorEmphasized.v1'; // persist emphasize set
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function resize(){ W = stage.clientWidth; H = stage.clientHeight; setViewBox(); redraw(); }
  window.addEventListener('resize', resize);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function loadEmph() {
    try { return new Set(JSON.parse(localStorage.getItem(EMPH_KEY) || '[]')); }
    catch { return new Set(); }
  }
  function saveEmph(set) {
    localStorage.setItem(EMPH_KEY, JSON.stringify(Array.from(set)));
  }

  // base font size from CSS, scaled by count
  function baseFontPx(total) {
    const cssSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    if (total <= 50) return cssSize;
    const drop = (total - 50) / 200; // 0..1 over next 200 names
    const scale = Math.max(0.6, 1 - 0.4 * drop);
    return cssSize * scale;
  }

  function wordsFromDonors() {
    const list = load().slice().sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    // Debug log: how many names in storage
    console.log('[DonorBoard] total donors:', list.length);
    const size = baseFontPx(list.length);
    return list.map(d => ({ text: d.name, key: keyName(d.name), size }));
  }

  let prevPos = new Map();
  let emphasized = loadEmph();

  function dynamicPadding(d) {
    const base = Math.max(12, Math.round(d.size * 0.4));
    const extra = Math.min(30, Math.floor(d.text.length * 0.8));
    return base + extra;
  }

  function hiDpiCanvas() {
    const ratio = (window.devicePixelRatio || 1);
    const c = document.createElement('canvas');
    c.width = Math.round(256 * ratio);
    c.height = Math.round(256 * ratio);
    const ctx = c.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return c;
  }

  // Strong vertical relaxation
  function relaxPositions(nextPos) {
    const keys = Array.from(nextPos.keys());
    const size = baseFontPx(keys.length);
    const nodes = keys.map(k => {
      const p = nextPos.get(k);
      const textLen = Math.max(6, k.length);
      return {
        key:k, x:p.x, y:p.y, rotate:p.rotate||0, size:p.size,
        w: Math.max(40, textLen * size * 0.62) + 12,
        h: size * 1.7 + 12
      };
    });

    const passes = 5;
    const pushX = 3, pushY = 10;
    const minRowGap = 8;

    for (let p=0; p<passes; p++) {
      for (let i=0; i<nodes.length; i++) {
        for (let j=i+1; j<nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const overlapX = Math.abs(a.x-b.x) < (a.w+b.w)/2;
          const overlapY = Math.abs(a.y-b.y) < (a.h+b.h)/2;
          if (overlapX && overlapY) {
            const sign = (a.y <= b.y) ? -1 : 1;
            a.y += sign * pushY;
            b.y -= sign * pushY;
            const hSign = (a.x <= b.x) ? -1 : 1;
            a.x += hSign * pushX;
            b.x -= hSign * pushX;
          } else if (overlapX && !overlapY) {
            const dy = Math.abs(a.y - b.y);
            if (dy < minRowGap) {
              const sgn = (a.y < b.y) ? -1 : 1;
              a.y += sgn * (minRowGap - dy)/2;
              b.y -= sgn * (minRowGap - dy)/2;
            }
          }
          // clamp to stage
          a.x = Math.max(a.w/2, Math.min(W - a.w/2, a.x));
          a.y = Math.max(a.h/2, Math.min(H - a.h/2, a.y));
          b.x = Math.max(b.w/2, Math.min(W - b.w/2, b.x));
          b.y = Math.max(b.h/2, Math.min(H - b.h/2, b.y));
        }
      }
    }

    nodes.forEach(n => nextPos.set(n.key, { x:n.x, y:n.y, rotate:n.rotate, size:n.size }));
    return nextPos;
  }

  function toggleEmphasize(nameKey){
    if (emphasized.has(nameKey)) emphasized.delete(nameKey);
    else emphasized.add(nameKey);
    saveEmph(emphasized);
    const p = prevPos.get(nameKey);
    const node = svg.selectAll('text.word').filter(function(){ return this.textContent && nameKey === keyName(this.textContent); });
    if (!node.size() || !p) { redraw(); return; }
    node.classed('emph', emphasized.has(nameKey))
      .transition().duration(250)
      .attr('transform', 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(' + (emphasized.has(nameKey)?1.35:1) + ')');
  }

  function redraw() {
    const CENTERX = W/2, CENTERY = H/2;
    const words = wordsFromDonors();

    const cloud = d3.layout.cloud()
      .canvas(hiDpiCanvas)
      .size([W, H])
      .words(words)
      .padding(dynamicPadding)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0)
      .on('end', draw);

    cloud.start();

    function draw(placed) {
      // Debug log: how many words were successfully placed
      console.log('[DonorBoard] placed words:', placed.length);

      let nextPos = new Map();
      placed.forEach(d => nextPos.set(keyName(d.text), { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

      nextPos = relaxPositions(nextPos);

      const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
      const sel = layer.selectAll('text.word').data(placed, d => d.text);

      sel.exit().transition().duration(300).style('opacity', 0).remove();

      const enter = sel.enter().append('text')
        .attr('class', 'word')
        .style('font-family', 'system-ui, sans-serif')
        .text(d => d.text)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .style('opacity', 0)
        .attr('font-size', d => d.size)
        .attr('transform', 'translate(' + CENTERX + ',' + CENTERY + ')');

      enter.merge(sel)
        .classed('emph', d => emphasized.has(keyName(d.text)))
        .transition().duration(600)
        .style('opacity', 1)
        .attr('font-size', d => d.size)
        .attr('transform', d => {
          const p = nextPos.get(keyName(d.text));
          const scale = emphasized.has(keyName(d.text)) ? 1.35 : 1;
          return 'translate(' + p.x + ',' + p.y + ') rotate(' + (d.rotate||0) + ') scale(' + scale + ')';
        });

      prevPos = nextPos;
    }
  }

  function fullRender() { prevPos.clear(); redraw(); }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) redraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      fullRender();
    }
    else if (msg.type === 'emphasize' && msg.name) {
      toggleEmphasize(keyName(msg.name));
    }
    else if (msg.type === 'remove' && msg.key) {
      redraw();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) redraw(); });

  setViewBox();
  fullRender();
})();
</script>
</body>
</html>