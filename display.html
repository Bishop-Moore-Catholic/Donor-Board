<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display</title>
<link rel="icon" href="assets/favicon.svg">
<link rel="stylesheet" href="styles.css">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
</head>
<body>
  <h1 class="db-title">Thank you to our generous donors</h1>
  <div id="stage"><svg id="cloud" aria-label="Donor word cloud"></svg></div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const EMPH_KEY = 'donorEmphasized.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function resize(){ W = stage.clientWidth; H = stage.clientHeight; setViewBox(); scheduleRedraw(); }
  window.addEventListener('resize', resize);

  const url = new URL(location.href);
  const bias = url.searchParams.get('bias') || 'balanced';
  const MAX_CAP = Math.min(+(url.searchParams.get('max') || 350), 10000);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function loadEmph() { try { return new Set(JSON.parse(localStorage.getItem(EMPH_KEY) || '[]')); } catch { return new Set(); } }
  function saveEmph(set) { localStorage.setItem(EMPH_KEY, JSON.stringify(Array.from(set))); }

  const cssBase = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
  const emphScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--emph-scale')) || 1.35;

  let prevPos = new Map();
  let emphasized = loadEmph();
  let inFlight = false;
  let pending = false;

  function measureFactory() {
    const ratio = window.devicePixelRatio || 1;
    const c = document.createElement('canvas'); c.width = 512*ratio; c.height = 160*ratio;
    const ctx = c.getContext('2d'); ctx.setTransform(ratio,0,0,ratio,0,0);
    return (text, px) => { ctx.font = px + 'px \"futura-pt\", system-ui, sans-serif'; return ctx.measureText(text).width; };
  }
  const measureText = measureFactory();

  function hiDpiCanvas() {
    const ratio = (window.devicePixelRatio || 1);
    const c = document.createElement('canvas');
    c.width = Math.round(256 * ratio);
    c.height = Math.round(256 * ratio);
    const ctx = c.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return c;
  }

  function seededRandom(seed) {
    let s = seed >>> 0;
    return function() { s ^= s << 13; s ^= s >>> 17; s ^= s << 5; return ((s>>>0)/4294967296); };
  }

  function relaxWithQuadtree(nextPos, sizePx){
    const nodes = Array.from(nextPos.entries()).map(([k,p]) => {
      const w = Math.max(40, measureText(k, sizePx) + 12);
      const h = sizePx * 1.5 + 8;
      return {key:k, x:p.x, y:p.y, w, h, rotate:p.rotate||0, size:p.size};
    });

    const passes = 8;
    for (let pass=0; pass<passes; pass++){
      const qt = d3.quadtree().x(d=>d.x).y(d=>d.y).addAll(nodes);
      nodes.forEach(n => {
        const r = Math.max(n.w, n.h);
        qt.visit((node, x0, y0, x1, y1) => {
          if (!node.data) return (x0 > n.x + r || x1 < n.x - r || y0 > n.y + r || y1 < n.y - r);
          const m = node.data; if (m === n) return false;
          const overlapX = Math.abs(n.x - m.x) < (n.w + m.w)/2;
          const overlapY = Math.abs(n.y - m.y) < (n.h + m.h)/2;
          if (overlapX && overlapY){
            const dx = (n.x - m.x) || (Math.random()-0.5);
            const dy = (n.y - m.y) || (Math.random()-0.5);
            const push = 4;
            n.x += (dx / (Math.abs(dx)+Math.abs(dy))) * push;
            n.y += (dy / (Math.abs(dx)+Math.abs(dy))) * push;
            m.x -= (dx / (Math.abs(dx)+Math.abs(dy))) * push;
            m.y -= (dy / (Math.abs(dx)+Math.abs(dy))) * push;
          }
          return false;
        });
        n.x = Math.max(n.w/2, Math.min(W - n.w/2, n.x));
        n.y = Math.max(n.h/2, Math.min(H - n.h/2, n.y));
      });
    }
    nodes.forEach(n => nextPos.set(n.key, {x:n.x, y:n.y, rotate:n.rotate, size:n.size}));
    return nextPos;
  }

  function scheduleRedraw(){ if (inFlight){ pending = true; return; } redrawAdaptive(); }

  function redrawAdaptive(){
    const donors0 = load().slice().sort((a,b)=> a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const donors = donors0.slice(0, MAX_CAP);
    const total = donors.length;
    console.log('[DonorBoard] total donors (capped):', total);

    let changed = false;
    emphasized.forEach(k => { if (!donors.find(d => keyName(d.name) === k)) { emphasized.delete(k); changed = true; } });
    if (changed) saveEmph(emphasized);

    const base = (total <= 50) ? cssBase() : cssBase() * Math.max(0.6, 1 - 0.4 * ((total - 50) / 200));
    const tries = [
      {scale:1.00, pad:1.00},
      {scale:0.94, pad:0.95},
      {scale:0.88, pad:0.90},
      {scale:0.82, pad:0.86},
      {scale:0.76, pad:0.82},
      {scale:0.70, pad:0.78},
    ];
    const accept = (bias==='larger') ? 0.80 : (bias==='denser' ? 0.97 : 0.95);

    const CENTERX = W/2, CENTERY = H/2;
    let attemptIndex = 0;
    inFlight = true;

    const seed = 123456 ^ total ^ Math.floor(W) ^ Math.floor(H);
    const rng = seededRandom(seed);

    (function attempt(){
      if (attemptIndex >= tries.length){ inFlight=false; if (pending){ pending=false; redrawAdaptive(); } return; }
      const t = tries[attemptIndex++];
      const fontPx = base * t.scale;
      const padScale = t.pad;

      const words = donors.map(d => ({ text: d.name, key: keyName(d.name), size: fontPx }));
      const cloud = d3.layout.cloud()
        .canvas(hiDpiCanvas)
        .size([W, H])
        .words(words)
        .padding(d => Math.round((Math.max(8, fontPx*0.3) + Math.min(24, d.text.length*0.5)) * padScale))
        .font('futura-pt, system-ui, sans-serif')
        .fontSize(d => d.size)
        .spiral('rectangular')
        .random(rng)
        .rotate(() => 0)
        .on('end', placed => {
          console.log('[DonorBoard] attempt', attemptIndex, 'fontPx', fontPx.toFixed(1), 'padScale', padScale, 'placed', placed.length);
          const ratio = placed.length / (total || 1);
          if (ratio < accept && attemptIndex < tries.length) { attempt(); return; }

          let nextPos = new Map();
          placed.forEach(d => nextPos.set(d.key, { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

          nextPos = relaxWithQuadtree(nextPos, fontPx);

          const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
          const sel = layer.selectAll('text.word').data(placed, d => d.key);

          sel.exit().transition().duration(150).style('opacity', 0).remove();

          const enter = sel.enter().append('text')
            .attr('class', 'word')
            .style('font-family', 'futura-pt, system-ui, sans-serif')
            .text(d => d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', d => d.size)
            .attr('transform', 'translate(' + CENTERX + ',' + CENTERY + ')');

          enter.merge(sel)
            .classed('emph', d => emphasized.has(d.key))
            .transition().duration(360)
            .style('opacity', 1)
            .attr('font-size', d => d.size)
            .attr('transform', d => {
              const p = nextPos.get(d.key);
              const scale = emphasized.has(d.key) ? emphScale : 1;
              return 'translate(' + p.x + ',' + p.y + ') rotate(' + (d.rotate||0) + ') scale(' + scale + ')';
            });

          prevPos = nextPos;
          inFlight = false;
          if (pending){ pending = false; redrawAdaptive(); }
        });

      cloud.start();
    })();
  }

  function toggleEmphasize(nameKey){
    if (emphasized.has(nameKey)) emphasized.delete(nameKey);
    else emphasized.add(nameKey);
    saveEmph(emphasized);
    const p = prevPos.get(nameKey);
    const node = svg.selectAll('text.word').filter(function(){ return this.textContent && nameKey === (this.textContent.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase(); });
    if (!node.size() || !p) { scheduleRedraw(); return; }
    node.classed('emph', emphasized.has(nameKey))
      .transition().duration(200)
      .attr('transform', 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(' + (emphasized.has(nameKey)?emphScale:1) + ')');
  }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) scheduleRedraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      prevPos.clear();
      emphasized.clear(); saveEmph(emphasized);
      scheduleRedraw();
    }
    else if (msg.type === 'clearEmph') { emphasized.clear(); saveEmph(emphasized); scheduleRedraw(); }
    else if (msg.type === 'emphasize' && msg.name) {
      const k = (msg.name.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase();
      toggleEmphasize(k);
    }
    else if (msg.type === 'remove' && msg.key) {
      emphasized.delete(msg.key); saveEmph(emphasized);
      scheduleRedraw();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY || e.key === EMPH_KEY) scheduleRedraw(); });

  setViewBox();
  scheduleRedraw();
})();
</script>
</body>
</html>
