<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (adaptive + stable RNG)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { fill:#111; dominant-baseline: middle; text-anchor: middle; }
  .word.emph { font-weight: 700; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const EMPH_KEY = 'donorEmphasized.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function resize(){ W = stage.clientWidth; H = stage.clientHeight; setViewBox(); scheduleRedraw(); }
  window.addEventListener('resize', resize);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function loadEmph() { try { return new Set(JSON.parse(localStorage.getItem(EMPH_KEY) || '[]')); } catch { return new Set(); } }
  function saveEmph(set) { localStorage.setItem(EMPH_KEY, JSON.stringify(Array.from(set))); }

  const cssBase = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;

  let prevPos = new Map();
  let emphasized = loadEmph();
  let inFlight = false;
  let pending = false;

  function dynamicPadding(d, padScale=1) {
    const base = Math.max(10, Math.round(d.size * 0.33));
    const extra = Math.min(24, Math.floor(d.text.length * 0.6));
    return Math.round((base + extra) * padScale);
  }

  function hiDpiCanvas() {
    const ratio = (window.devicePixelRatio || 1);
    const c = document.createElement('canvas');
    c.width = Math.round(256 * ratio);
    c.height = Math.round(256 * ratio);
    const ctx = c.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return c;
  }

  // Seeded RNG for stability
  function seededRandom(seed) {
    let s = seed >>> 0;
    return function() {
      // xorshift32
      s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
      return ((s >>> 0) / 4294967296);
    };
  }

  function relaxPositions(nextPos, sizePx) {
    const keys = Array.from(nextPos.keys());
    const nodes = keys.map(k => {
      const p = nextPos.get(k);
      const textLen = Math.max(6, k.length);
      return {
        key:k, x:p.x, y:p.y, rotate:p.rotate||0, size:p.size,
        w: Math.max(40, textLen * sizePx * 0.62) + 12,
        h: sizePx * 1.7 + 12
      };
    });

    const passes = 5;
    const pushX = 3, pushY = 10;
    const minRowGap = 8;

    for (let p=0; p<passes; p++) {
      for (let i=0; i<nodes.length; i++) {
        for (let j=i+1; j<nodes.length; j++) {
          const a = nodes[i], b = nodes[j];
          const overlapX = Math.abs(a.x-b.x) < (a.w+b.w)/2;
          const overlapY = Math.abs(a.y-b.y) < (a.h+b.h)/2;
          if (overlapX && overlapY) {
            const sign = (a.y <= b.y) ? -1 : 1;
            a.y += sign * pushY;
            b.y -= sign * pushY;
            const hSign = (a.x <= b.x) ? -1 : 1;
            a.x += hSign * pushX;
            b.x -= hSign * pushX;
          } else if (overlapX && !overlapY) {
            const dy = Math.abs(a.y - b.y);
            if (dy < minRowGap) {
              const sgn = (a.y < b.y) ? -1 : 1;
              a.y += sgn * (minRowGap - dy)/2;
              b.y -= sgn * (minRowGap - dy)/2;
            }
          }
          a.x = Math.max(a.w/2, Math.min(W - a.w/2, a.x));
          a.y = Math.max(a.h/2, Math.min(H - a.h/2, a.y));
          b.x = Math.max(b.w/2, Math.min(W - b.w/2, b.x));
          b.y = Math.max(b.h/2, Math.min(H - b.h/2, b.y));
        }
      }
    }

    nodes.forEach(n => nextPos.set(n.key, { x:n.x, y:n.y, rotate:n.rotate, size:n.size }));
    return nextPos;
  }

  function scheduleRedraw(){
    if (inFlight){ pending = true; return; }
    redrawAdaptive();
  }

  function redrawAdaptive(){
    const donors = load().slice().sort((a,b)=> a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const total = donors.length;
    console.log('[DonorBoard] total donors:', total);

    // Remove emphasized flags for names that no longer exist
    let changed = false;
    emphasized.forEach(k => {
      if (!donors.find(d => k === (d.name.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase())) {
        emphasized.delete(k); changed = true;
      }
    });
    if (changed) saveEmph(emphasized);

    // Base font size and adaptive trials
    const base = (total <= 50) ? cssBase() : cssBase() * Math.max(0.58, 1 - 0.42 * ((total - 50) / 200));
    const tries = [
      {scale:1.00, pad:1.00},
      {scale:0.92, pad:0.95},
      {scale:0.85, pad:0.9},
      {scale:0.78, pad:0.85},
      {scale:0.72, pad:0.80},
      {scale:0.66, pad:0.78},
    ];

    const CENTERX = W/2, CENTERY = H/2;
    let attemptIndex = 0;
    inFlight = true;

    const seed = 123456 ^ total ^ Math.floor(W) ^ Math.floor(H); // stable per geometry & count
    const rng = seededRandom(seed);

    (function attempt(){
      if (attemptIndex >= tries.length){ inFlight=false; if (pending){ pending=false; redrawAdaptive(); } return; }
      const t = tries[attemptIndex++];
      const fontPx = base * t.scale;
      const padScale = t.pad;

      const words = donors.map(d => ({ text: d.name, key: (d.name.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase(), size: fontPx }));

      const cloud = d3.layout.cloud()
        .canvas(hiDpiCanvas)
        .size([W, H])
        .words(words)
        .padding(d => dynamicPadding(d, padScale))
        .font('system-ui, sans-serif')
        .fontSize(d => d.size)
        .spiral('rectangular')
        .random(rng)
        .rotate(() => 0)
        .on('end', placed => {
          console.log('[DonorBoard] attempt', attemptIndex, 'fontPx', fontPx.toFixed(1), 'padScale', padScale, 'placed', placed.length);
          const need = Math.min(total, 400); // cap for perf/legibility
          if (placed.length < Math.min(need, Math.floor(total * 0.85)) && attemptIndex < tries.length) {
            attempt(); // try smaller
            return;
          }

          let nextPos = new Map();
          placed.forEach(d => nextPos.set(d.key, { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));
          nextPos = relaxPositions(nextPos, fontPx);

          const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
          const sel = layer.selectAll('text.word').data(placed, d => d.key);

          sel.exit().transition().duration(200).style('opacity', 0).remove();

          const enter = sel.enter().append('text')
            .attr('class', 'word')
            .style('font-family', 'system-ui, sans-serif')
            .text(d => d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', d => d.size)
            .attr('transform', 'translate(' + CENTERX + ',' + CENTERY + ')');

          enter.merge(sel)
            .classed('emph', d => emphasized.has(d.key))
            .transition().duration(450)
            .style('opacity', 1)
            .attr('font-size', d => d.size)
            .attr('transform', d => {
              const p = nextPos.get(d.key);
              const scale = emphasized.has(d.key) ? 1.35 : 1;
              return 'translate(' + p.x + ',' + p.y + ') rotate(' + (d.rotate||0) + ') scale(' + scale + ')';
            });

          prevPos = nextPos;
          inFlight = false;
          if (pending){ pending = false; redrawAdaptive(); }
        });

      cloud.start();
    })();
  }

  function toggleEmphasize(nameKey){
    if (emphasized.has(nameKey)) emphasized.delete(nameKey);
    else emphasized.add(nameKey);
    saveEmph(emphasized);
    const p = prevPos.get(nameKey);
    const node = svg.selectAll('text.word').filter(function(){ return this.textContent && nameKey === (this.textContent.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase(); });
    if (!node.size() || !p) { scheduleRedraw(); return; }
    node.classed('emph', emphasized.has(nameKey))
      .transition().duration(200)
      .attr('transform', 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ') scale(' + (emphasized.has(nameKey)?1.35:1) + ')');
  }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) scheduleRedraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      prevPos.clear();
      emphasized.clear(); saveEmph(emphasized); // also clear emphasize on resets
      scheduleRedraw();
    }
    else if (msg.type === 'clearEmph') { emphasized.clear(); saveEmph(emphasized); scheduleRedraw(); }
    else if (msg.type === 'emphasize' && msg.name) {
      const k = (msg.name.normalize('NFKC').replace(/\s+/g,' ').trim()).toLowerCase();
      toggleEmphasize(k);
    }
    else if (msg.type === 'remove' && msg.key) {
      emphasized.delete(msg.key); saveEmph(emphasized);
      scheduleRedraw();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY || e.key === EMPH_KEY) scheduleRedraw(); });

  setViewBox();
  scheduleRedraw();
})();
</script>
</body>
</html>