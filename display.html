<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board – Display</title>
<link rel="icon" href="assets/favicon.svg">
<link rel="stylesheet" href="styles.css">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
</head>
<body>
  <h1 class="db-title">Thank You To Our Generous Donors!</h1>
  <div id="stage"><svg id="cloud" aria-label="Donor word cloud"></svg></div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const EMPH_KEY = 'donorEmphasized.v1';
  const THEME_KEY = 'donorTheme.v1';
  const MSG_KEY = 'donorBroadcast.v1';
  const channel = (() => {
    try { return new BroadcastChannel('donors'); }
    catch (err) {
      console.warn('[DonorDisplay] BroadcastChannel unavailable:', err);
      return null;
    }
  })();
  const handledQueue = [];
  const handledSet = new Set();
  const MAX_HANDLED = 200;
  function alreadyHandled(id){
    if (!id) return false;
    if (handledSet.has(id)) return true;
    handledSet.add(id);
    handledQueue.push(id);
    if (handledQueue.length > MAX_HANDLED) {
      const oldest = handledQueue.shift();
      handledSet.delete(oldest);
    }
    return false;
  }
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  const rootStyle = document.documentElement.style;
  function applyTheme(theme){
    if (!theme) return;
    rootStyle.setProperty('--bg', theme.bg);
    rootStyle.setProperty('--title-color', theme.titleColor);
    rootStyle.setProperty('--name-color', theme.nameColor);
    rootStyle.setProperty('--name-weight', String(theme.nameWeight));
    rootStyle.setProperty('--emph-color', theme.emphColor);
    rootStyle.setProperty('--emph-weight', String(theme.emphWeight));
    rootStyle.setProperty('--emph-scale', String(theme.emphScale));
    if (theme.bgImageData) {
      document.body.style.backgroundImage = `url(${theme.bgImageData})`;
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center';
    } else {
      document.body.style.backgroundImage = 'none';
    }
    scheduleRedraw();
  }
  function loadTheme(){ try { return JSON.parse(localStorage.getItem(THEME_KEY) || 'null'); } catch { return null; } }
  function saveTheme(theme){ localStorage.setItem(THEME_KEY, JSON.stringify(theme)); }
  const lastState = {
    donors: localStorage.getItem(KEY),
    emph: localStorage.getItem(EMPH_KEY),
    theme: localStorage.getItem(THEME_KEY),
    msg: localStorage.getItem(MSG_KEY),
  };
  const serializeEmphasis = (set) => JSON.stringify(Array.from(set));
  function setEmphasisFromKeys(keys, { persist = false } = {}) {
    emphasized = new Set((Array.isArray(keys) ? keys : []).map(k => keyName(String(k || ''))));
    if (persist) {
      saveEmph(emphasized);
      lastState.emph = serializeEmphasis(emphasized);
    }
  }
  function refreshEmphasisStyles(){
    const nodes = svg.selectAll('text.word');
    if (!nodes.size() || !prevPos.size) { scheduleRedraw(); return; }
    const scaleVal = emphScale();
    let missing = false;
    nodes.each(function(d){
      const key = (d && d.key) || keyName(this.textContent || '');
      const pos = prevPos.get(key);
      if (!pos) { missing = true; return; }
      const isEmph = emphasized.has(key);
      d3.select(this)
        .classed('emph', isEmph)
        .transition().duration(200)
        .attr('transform', 'translate(' + pos.x + ',' + pos.y + ') rotate(' + (pos.rotate || 0) + ') scale(' + (isEmph ? scaleVal : 1) + ')');
    });
    if (missing) scheduleRedraw();
  }
  function syncEmphasisFromStorage(){
    emphasized = loadEmph();
    lastState.emph = localStorage.getItem(EMPH_KEY);
    refreshEmphasisStyles();
  }

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function resize(){ W = stage.clientWidth; H = stage.clientHeight; setViewBox(); scheduleRedraw(); }
  window.addEventListener('resize', resize);

  const url = new URL(location.href);
  const bias = url.searchParams.get('bias') || 'balanced';
  const MAX_CAP = Math.min(+(url.searchParams.get('max') || 350), 10000);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function loadEmph() { try { return new Set(JSON.parse(localStorage.getItem(EMPH_KEY) || '[]')); } catch { return new Set(); } }
  function saveEmph(set) { localStorage.setItem(EMPH_KEY, JSON.stringify(Array.from(set))); }

  const cssBase = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
  const emphScale = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--emph-scale')) || 1.35;

  let prevPos = new Map();
  let emphasized = loadEmph();
  let inFlight = false;
  let pending = false;
  let activeCloud = null;
  let layoutWatchdog = null;
  let layoutEpoch = 0;
  const WATCHDOG_MIN = 3500;
  const WATCHDOG_MAX = 12000;

  function measureFactory() {
    const ratio = window.devicePixelRatio || 1;
    const c = document.createElement('canvas'); c.width = 512*ratio; c.height = 160*ratio;
    const ctx = c.getContext('2d'); ctx.setTransform(ratio,0,0,ratio,0,0);
    return (text, px) => { ctx.font = px + 'px \"futura-pt\", system-ui, sans-serif'; return ctx.measureText(text).width; };
  }
  const measureText = measureFactory();

  function hiDpiCanvas() {
    const ratio = (window.devicePixelRatio || 1);
    const c = document.createElement('canvas');
    c.width = Math.round(256 * ratio);
    c.height = Math.round(256 * ratio);
    const ctx = c.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return c;
  }

  function seededRandom(seed) {
    let s = seed >>> 0;
    return function() { s ^= s << 13; s ^= s >>> 17; s ^= s << 5; return ((s>>>0)/4294967296); };
  }

  function relaxWithQuadtree(nextPos, sizePx){
    const nodes = Array.from(nextPos.entries()).map(([k,p]) => {
      const w = Math.max(40, measureText(k, sizePx) + 12);
      const h = sizePx * 1.5 + 8;
      return {key:k, x:p.x, y:p.y, w, h, rotate:p.rotate||0, size:p.size};
    });

    const passes = 8;
    for (let pass=0; pass<passes; pass++){
      const qt = d3.quadtree().x(d=>d.x).y(d=>d.y).addAll(nodes);
      nodes.forEach(n => {
        const r = Math.max(n.w, n.h);
        qt.visit((node, x0, y0, x1, y1) => {
          if (!node.data) return (x0 > n.x + r || x1 < n.x - r || y0 > n.y + r || y1 < n.y - r);
          const m = node.data; if (m === n) return false;
          const overlapX = Math.abs(n.x - m.x) < (n.w + m.w)/2;
          const overlapY = Math.abs(n.y - m.y) < (n.h + m.h)/2;
          if (overlapX && overlapY){
            const dx = (n.x - m.x) || (Math.random()-0.5);
            const dy = (n.y - m.y) || (Math.random()-0.5);
            const push = 4;
            n.x += (dx / (Math.abs(dx)+Math.abs(dy))) * push;
            n.y += (dy / (Math.abs(dx)+Math.abs(dy))) * push;
            m.x -= (dx / (Math.abs(dx)+Math.abs(dy))) * push;
            m.y -= (dy / (Math.abs(dx)+Math.abs(dy))) * push;
          }
          return false;
        });
        n.x = Math.max(n.w/2, Math.min(W - n.w/2, n.x));
        n.y = Math.max(n.h/2, Math.min(H - n.h/2, n.y));
      });
    }
    nodes.forEach(n => nextPos.set(n.key, {x:n.x, y:n.y, rotate:n.rotate, size:n.size}));
    return nextPos;
  }

  function clearLayoutWatchdog(){
    if (layoutWatchdog) {
      clearTimeout(layoutWatchdog);
      layoutWatchdog = null;
    }
  }
  function startLayoutWatchdog(wordCount, epoch){
    clearLayoutWatchdog();
    const timeout = Math.min(WATCHDOG_MAX, Math.max(WATCHDOG_MIN, (wordCount || 1) * 15));
    const watchEpoch = typeof epoch === 'number' ? epoch : layoutEpoch;
    layoutWatchdog = setTimeout(() => {
      if (watchEpoch !== layoutEpoch) return;
      console.warn('[DonorDisplay] Layout watchdog fired after', timeout, 'ms — retrying layout.');
      abortActiveLayout();
    }, timeout);
  }
  function abortActiveLayout(){
    if (!inFlight) return;
    if (activeCloud && typeof activeCloud.stop === 'function') {
      try { activeCloud.stop(); } catch {}
    }
    activeCloud = null;
    clearLayoutWatchdog();
    inFlight = false;
    pending = false;
    requestAnimationFrame(() => redrawAdaptive());
  }

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  function scheduleRedraw(){ if (inFlight){ pending = true; return; } redrawAdaptive(); }

  function redrawAdaptive(){
    const donors0 = load().slice().sort((a,b)=> a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const donors = donors0.slice(0, MAX_CAP);
    const total = donors.length;
    console.log('[DonorBoard] total donors (capped):', total);
    const layoutRunEpoch = ++layoutEpoch;
    clearLayoutWatchdog();

    let changed = false;
    emphasized.forEach(k => { if (!donors.find(d => keyName(d.name) === k)) { emphasized.delete(k); changed = true; } });
    if (changed) {
      saveEmph(emphasized);
      lastState.emph = serializeEmphasis(emphasized);
    }

    const base = (total <= 50) ? cssBase() : cssBase() * Math.max(0.6, 1 - 0.4 * ((total - 50) / 200));
    const tries = [
      {scale:1.00, pad:1.00},
      {scale:0.94, pad:0.95},
      {scale:0.88, pad:0.90},
      {scale:0.82, pad:0.86},
      {scale:0.76, pad:0.82},
      {scale:0.70, pad:0.78},
    ];
    const accept = (bias==='larger') ? 0.80 : (bias==='denser' ? 0.97 : 0.95);

    const CENTERX = W/2, CENTERY = H/2;
    let attemptIndex = 0;
    inFlight = true;
    layoutEpoch++;
    clearLayoutWatchdog();

    const seed = 123456 ^ total ^ Math.floor(W) ^ Math.floor(H);
    const rng = seededRandom(seed);

    (function attempt(){
      if (attemptIndex >= tries.length){
        clearLayoutWatchdog();
        activeCloud = null;
        inFlight=false;
        if (pending){ pending=false; redrawAdaptive(); }
        return;
      }
      const t = tries[attemptIndex++];
      const fontPx = base * t.scale;
      const padScale = t.pad;

      const words = donors.map(d => ({ text: d.name, key: keyName(d.name), size: fontPx }));
      const cloud = d3.layout.cloud()
        .canvas(hiDpiCanvas)
        .size([W, H])
        .words(words)
        .padding(d => Math.round((Math.max(8, fontPx*0.3) + Math.min(24, d.text.length*0.5)) * padScale))
        .font('futura-pt, system-ui, sans-serif')
        .fontSize(d => d.size)
        .spiral('rectangular')
        .random(rng)
        .rotate(() => 0)
        .on('end', placed => {
          console.log('[DonorBoard] attempt', attemptIndex, 'fontPx', fontPx.toFixed(1), 'padScale', padScale, 'placed', placed.length);
          const ratio = placed.length / (total || 1);
          activeCloud = null;
          clearLayoutWatchdog();
          if (ratio < accept && attemptIndex < tries.length) { attempt(); return; }

          let nextPos = new Map();
          placed.forEach(d => nextPos.set(d.key, { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

          nextPos = relaxWithQuadtree(nextPos, fontPx);

          const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
          const sel = layer.selectAll('text.word').data(placed, d => d.key);

          sel.exit().transition().duration(150).style('opacity', 0).remove();

          const enter = sel.enter().append('text')
            .attr('class', 'word')
            .style('font-family', 'futura-pt, system-ui, sans-serif')
            .text(d => d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', d => d.size)
            .attr('transform', 'translate(' + CENTERX + ',' + CENTERY + ')');

          const merged = enter.merge(sel).interrupt();
          merged
            .classed('emph', d => emphasized.has(d.key))
            .transition().duration(360)
            .style('opacity', 1)
            .attr('font-size', d => d.size)
            .attr('transform', d => {
              const p = nextPos.get(d.key);
              const scale = emphasized.has(d.key) ? (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--emph-scale')) || 1.35) : 1;
              return 'translate(' + p.x + ',' + p.y + ') rotate(' + (d.rotate||0) + ') scale(' + scale + ')';
            });
          setTimeout(() => {
            merged.style('opacity', 1);
          }, 720);

          prevPos = nextPos;
          inFlight = false;
          if (pending){ pending = false; redrawAdaptive(); }
        });

      activeCloud = cloud;
      startLayoutWatchdog(donors.length, layoutRunEpoch);
      cloud.start();
    })();
  }

  function handleMessage(rawMsg){
    const msg = rawMsg || {};
    if (alreadyHandled(msg._id)) return;
    if (msg.type === 'themeUpdate' && msg.theme) {
      saveTheme(msg.theme);
      applyTheme(msg.theme);
    }
    else if (msg.type === 'added' && Array.isArray(msg.donors)) scheduleRedraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      prevPos.clear();
      emphasized.clear();
      saveEmph(emphasized);
      lastState.emph = serializeEmphasis(emphasized);
      scheduleRedraw();
    }
    else if (msg.type === 'clearEmph') {
      emphasized.clear();
      saveEmph(emphasized);
      lastState.emph = serializeEmphasis(emphasized);
      refreshEmphasisStyles();
    }
    else if (msg.type === 'emphasisSync' && Array.isArray(msg.keys)) {
      setEmphasisFromKeys(msg.keys, { persist: true });
      refreshEmphasisStyles();
    }
    else if (msg.type === 'emphasize') {
      syncEmphasisFromStorage();
    }
    else if (msg.type === 'remove' && msg.key) {
      const changed = emphasized.delete(msg.key);
      if (changed) {
        saveEmph(emphasized);
        lastState.emph = serializeEmphasis(emphasized);
        refreshEmphasisStyles();
      }
      scheduleRedraw();
    }
  }

  if (channel) channel.onmessage = (ev) => handleMessage(ev.data || {});

  const savedTheme = loadTheme(); if (savedTheme) applyTheme(savedTheme);
  function pollLocalState(){
    try {
      const donorsRaw = localStorage.getItem(KEY);
      if (donorsRaw !== lastState.donors) {
        lastState.donors = donorsRaw;
        scheduleRedraw();
      }
      const emphRaw = localStorage.getItem(EMPH_KEY);
      if (emphRaw !== lastState.emph) {
        lastState.emph = emphRaw;
        emphasized = loadEmph();
        refreshEmphasisStyles();
      }
      const themeRaw = localStorage.getItem(THEME_KEY);
      if (themeRaw !== lastState.theme) {
        lastState.theme = themeRaw;
        const latestTheme = loadTheme();
        if (latestTheme) applyTheme(latestTheme);
      }
      const msgRaw = localStorage.getItem(MSG_KEY);
      if (msgRaw && msgRaw !== lastState.msg) {
        lastState.msg = msgRaw;
        try { handleMessage(JSON.parse(msgRaw)); }
        catch (err) { console.error('[DonorDisplay] Poll parse failed', err); }
      }
    } catch (err) {
      console.error('[DonorDisplay] Poll failed', err);
    }
  }
  pollLocalState();
  setInterval(pollLocalState, 1000);
  window.addEventListener('storage', (e) => {
    if (e.key === MSG_KEY && e.newValue) {
      lastState.msg = e.newValue;
      try { handleMessage(JSON.parse(e.newValue)); } catch (err) { console.error('[DonorDisplay] Failed to parse broadcast fallback', err); }
      return;
    }
    if (e.key === KEY) {
      lastState.donors = e.newValue;
      scheduleRedraw();
      return;
    }
    if (e.key === EMPH_KEY) {
      lastState.emph = e.newValue;
      emphasized = loadEmph();
      refreshEmphasisStyles();
      return;
    }
    if (e.key === THEME_KEY) {
      lastState.theme = e.newValue;
      const latestTheme = loadTheme();
      if (latestTheme) applyTheme(latestTheme);
      scheduleRedraw();
    }
  });

  function setViewBox(){ svg.attr('viewBox', '0 0 ' + W + ' ' + H); }
  setViewBox();
  scheduleRedraw();
})();
</script>
</body>
</html>
