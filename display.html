<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (d3-cloud streaming, fixed)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function setViewBox(){
    // use string concat to avoid template literal escaping issues
    svg.attr('viewBox', '0 0 ' + W + ' ' + H);
  }
  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    setViewBox();
    redraw();
  }
  window.addEventListener('resize', resize);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function wordsFromDonors() {
    const baseSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    const list = load().slice().sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    return list.map(d => ({ text: d.name, key: keyName(d.name), size: baseSizePx }));
  }

  let prevPos = new Map(); // key -> {x,y,rotate,size}

  function redraw() {
    const CENTERX = W/2, CENTERY = H/2;
    const words = wordsFromDonors();
    const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');
    const streamed = new Set();

    const cloud = d3.layout.cloud()
      .size([W, H])
      .words(words)
      .padding(4)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0)
      .timeInterval(10)
      .on('word', d => {
        const k = keyName(d.text);
        if (streamed.has(k)) return;
        streamed.add(k);
        const pos = { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size };

        // Try to select existing node by matching textContent (since old nodes may have no bound data yet)
        let node = layer.selectAll('text.word').filter(function(){ return this.textContent === d.text; });
        if (!node.size()) {
          node = layer.append('text')
            .attr('class', 'word')
            .style('font-family', 'system-ui, sans-serif')
            .text(d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', (prevPos.get(k) && prevPos.get(k).size) || d.size)
            .attr('transform', () => {
              const p = prevPos.get(k);
              const x0 = p ? p.x : CENTERX, y0 = p ? p.y : CENTERY, r0 = p ? p.rotate : 0;
              return 'translate(' + x0 + ',' + y0 + ') rotate(' + r0 + ')';
            });
        }
        node.transition().duration(500)
          .style('opacity', 1)
          .attr('font-size', pos.size)
          .attr('transform', 'translate(' + pos.x + ',' + pos.y + ') rotate(' + pos.rotate + ')');
      })
      .on('end', placed => {
        const nextPos = new Map();
        placed.forEach(d => nextPos.set(keyName(d.text), { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

        // Safe key function: fall back to element text if old data is undefined
        const sel = layer.selectAll('text.word').data(placed, function(d){ return d ? d.text : this.textContent; });

        sel.exit().transition().duration(400).style('opacity', 0).remove();

        const enter = sel.enter().append('text')
          .attr('class', 'word')
          .style('font-family', 'system-ui, sans-serif')
          .text(d => d.text)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('opacity', 0)
          .attr('font-size', d => (prevPos.get(keyName(d.text))?.size || d.size))
          .attr('transform', function(){
            const p = prevPos.get(keyName(this.textContent));
            const x0 = p ? p.x : CENTERX, y0 = p ? p.y : CENTERY, r0 = p ? p.rotate : 0;
            return 'translate(' + x0 + ',' + y0 + ') rotate(' + r0 + ')';
          });

        enter.merge(sel)
          .transition().duration(700)
          .style('opacity', 1)
          .attr('font-size', d => d.size)
          .attr('transform', d => {
            const p = nextPos.get(keyName(d.text));
            return 'translate(' + p.x + ',' + p.y + ') rotate(' + p.rotate + ')';
          });

        prevPos = nextPos;
      });

    cloud.start();
  }

  function fullRender() { prevPos.clear(); redraw(); }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) redraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      fullRender();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) redraw(); });

  // boot
  setViewBox();
  fullRender();
})();
</script>
</body>
</html>