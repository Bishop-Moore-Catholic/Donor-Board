<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board – Display (incremental)</title>
<link rel="icon" href="assets/favicon.svg">
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); --padding: 8; }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { width:100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); dominant-baseline: middle; text-anchor: middle; fill:#111; }
  .word.new { transform-origin: center center; transform-box: fill-box; animation: pop 3.2s ease-out both; }
  @keyframes pop { 0% { transform: scale(2.0); opacity: 0; } 10% { opacity: 1; } 100% { transform: scale(1); opacity: 1; } }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const POS_KEY = 'donorPositions.v1';
  const CH = new BroadcastChannel('donors');
  const svg = document.getElementById('cloud');
  const stage = document.getElementById('stage');

  let W = stage.clientWidth, H = stage.clientHeight;
  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  }
  window.addEventListener('resize', resize);

  // Text measurement via canvas (fast + consistent)
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  function basePx(){
    const cs = getComputedStyle(document.documentElement).getPropertyValue('--base-size').trim();
    if (!cs) return 24;
    if (cs.endsWith('px')) return parseFloat(cs);
    // rough fallback for vw clamp: sample 2% of width
    return Math.max(18, Math.min(36, Math.round(window.innerWidth * 0.022)));
  }
  function measure(text){
    const size = basePx();
    ctx.font = `${size}px system-ui, sans-serif`;
    const w = ctx.measureText(text).width;
    const h = size * 1.15;
    const pad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--padding')) || 8;
    return { w: w + pad*2, h: h + pad*2, size };
  }

  // Positions cache
  function loadPositions(){
    try { return JSON.parse(localStorage.getItem(POS_KEY)) || {}; } catch { return {}; }
  }
  function savePositions(map){
    localStorage.setItem(POS_KEY, JSON.stringify(map));
  }

  // Donors
  function loadDonors(){
    try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; }
  }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  // Overlap check
  const placed = []; // {x,y,w,h,key,text}
  function overlaps(a,b){
    return !(a.x + a.w/2 <= b.x - b.w/2 ||
             a.x - a.w/2 >= b.x + b.w/2 ||
             a.y + a.h/2 <= b.y - b.h/2 ||
             a.y - a.h/2 >= b.y + b.h/2);
  }

  // Spiral search from center; find first non-overlapping spot
  function findSpot(rect){
    const cx = W/2, cy = H/2;
    let angle = 0, radius = 0;
    const step = 6;        // px per spiral step
    const angleStep = Math.PI / 24; // 7.5°
    let safety = 0, maxR = Math.hypot(W, H);

    while (radius < maxR && safety < 20000){
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;

      // keep fully inside bounds
      if (x - rect.w/2 >= 0 && x + rect.w/2 <= W && y - rect.h/2 >= 0 && y + rect.h/2 <= H) {
        let ok = true;
        for (let i=0;i<placed.length;i++){
          if (overlaps({x,y,w:rect.w,h:rect.h}, placed[i])) { ok = false; break; }
        }
        if (ok) return {x,y};
      }
      angle += angleStep;
      radius += step * angleStep / (2*Math.PI) * 20; // increases slowly
      safety++;
    }
    // fallback: center (may overlap if too dense)
    return { x: Math.max(rect.w/2, Math.min(W-rect.w/2, cx)), y: Math.max(rect.h/2, Math.min(H-rect.h/2, cy)) };
  }

  // Draw / update a single word at (x,y)
  function drawWord(text, x, y, isNew){
    const size = basePx();
    const key = keyName(text);
    let node = svg.querySelector(`text[data-key="${CSS.escape(key)}"]`);
    if (!node){
      node = document.createElementNS('http://www.w3.org/2000/svg','text');
      node.setAttribute('class', 'word' + (isNew ? ' new' : ''));
      node.setAttribute('data-key', key);
      node.setAttribute('text-anchor','middle');
      node.setAttribute('dominant-baseline','middle');
      node.textContent = text;
      svg.appendChild(node);
      // ensure animation class is applied after insertion for reliable start
      if (isNew){
        requestAnimationFrame(() => { node.classList.add('new'); });
      }
    }
    node.setAttribute('x', x.toFixed(1));
    node.setAttribute('y', y.toFixed(1));
    node.setAttribute('font-size', size);
  }

  // Initial render: keep prior positions if available; only place missing ones
  function fullRender(){
    resize();
    const donors = loadDonors().sort((a,b)=>a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const posMap = loadPositions();
    placed.length = 0;
    svg.innerHTML = ''; // clear all

    for (const d of donors){
      const key = keyName(d.name);
      const m = measure(d.name);
      let pos = posMap[key];
      if (!pos || isNaN(pos.x) || isNaN(pos.y)){
        pos = findSpot({w:m.w,h:m.h});
        posMap[key] = pos;
      }
      placed.push({x:pos.x,y:pos.y,w:m.w,h:m.h,key,text:d.name});
      drawWord(d.name, pos.x, pos.y, /*isNew*/ false);
    }
    savePositions(posMap);
  }

  // Add only new donors incrementally (no reshuffle)
  function addNew(donors){
    const posMap = loadPositions();
    const sorted = donors.map(d => d.name).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}));
    for (const name of sorted){
      const key = keyName(name);
      if (placed.find(p => p.key === key)) continue; // already there
      const m = measure(name);
      const spot = findSpot({w:m.w,h:m.h});
      placed.push({x:spot.x,y:spot.y,w:m.w,h:m.h,key,text:name});
      posMap[key] = spot;
      drawWord(name, spot.x, spot.y, /*isNew*/ true);
    }
    savePositions(posMap);
  }

  // Listen to updates
  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) addNew(msg.donors);
    else if (msg.type === 'reset') {
      localStorage.removeItem(POS_KEY);
      fullRender();
    }
  };

  window.addEventListener('storage', (e) => {
    if (e.key === KEY) fullRender();
  });

  // Boot
  fullRender();
})();
</script>
</body>
</html>