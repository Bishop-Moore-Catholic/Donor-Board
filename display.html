<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (d3-cloud basic, no animations)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    svg.attr('viewBox', `0 0 ${W} ${H}`);
    drawLayout(); // reflow on resize
  }
  window.addEventListener('resize', resize);

  function load() {
    try { return JSON.parse(localStorage.getItem(KEY)) || []; }
    catch { return []; }
  }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();

  function getWords() {
    const list = load();
    // Simple stable order: alphabetical for now
    const ordered = list.slice().sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    const baseSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    return ordered.map(d => ({ text: d.name, size: baseSizePx }));
  }

  let layoutToken = 0;

  function drawLayout() {
    const baseWords = getWords();
    const token = ++layoutToken;

    if (!baseWords.length) {
      svg.selectAll('*').remove();
      return;
    }

    const PAD = 4;
    const MIN_SIZE = 12;
    const MAX_ATTEMPTS = 8;
    let attempt = 0;
    let scale = 1;

    function runLayout() {
      const words = baseWords.map(d => ({
        text: d.text,
        size: Math.max(MIN_SIZE, d.size * scale)
      }));

      const cloud = d3.layout.cloud()
        .size([W, H])
        .words(words)
        .padding(PAD)
        .font('system-ui, sans-serif')
        .fontSize(d => d.size)
        .rotate(() => 0)
        .spiral('archimedean')
        .on('end', positioned => {
          if (token !== layoutToken) return; // stale run

          if (!positioned.length) {
            svg.selectAll('*').remove();
            return;
          }

          const minX = d3.min(positioned, d => d.x - d.width / 2) ?? 0;
          const maxX = d3.max(positioned, d => d.x + d.width / 2) ?? 0;
          const minY = d3.min(positioned, d => d.y - d.height / 2) ?? 0;
          const maxY = d3.max(positioned, d => d.y + d.height / 2) ?? 0;

          const boundsWidth = maxX - minX + PAD * 2;
          const boundsHeight = maxY - minY + PAD * 2;

          const fits = boundsWidth <= W && boundsHeight <= H;

          if (!fits && attempt < MAX_ATTEMPTS) {
            const shrinkX = W / boundsWidth;
            const shrinkY = H / boundsHeight;
            const shrink = Math.max(0.5, Math.min(shrinkX, shrinkY) * 0.95);
            if (shrink < 1) {
              scale *= shrink;
            } else {
              scale *= 0.9;
            }
            attempt++;
            runLayout();
            return;
          }

          draw(positioned);
        });

      cloud.start();
    }

    runLayout();

    function draw(wds) {
      const CENTERX = W / 2;
      const CENTERY = H / 2;

      const g = svg.selectAll('g.words').data([null]);
      g.enter().append('g').attr('class', 'words');
      const layer = svg.select('g.words');

      const sel = layer.selectAll('text.word').data(wds, d => d.text);

      sel.exit().remove();

      const enter = sel.enter().append('text')
        .attr('class', 'word')
        .style('font-family', 'system-ui, sans-serif')
        .text(d => d.text)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle');

      enter.merge(sel)
        .attr('font-size', d => d.size)
        .attr('transform', d => `translate(${d.x + CENTERX},${d.y + CENTERY}) rotate(${d.rotate || 0})`);
    }
  }

  function fullRender() { drawLayout(); }

  function addNew() {
    // For debugging, just re-run layout (no animations); order is stable so layout is reasonably consistent
    drawLayout();
  }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) addNew();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      fullRender();
    }
  };

  // Boot
  resize();
  fullRender();
})();
</script>
</body>
</html>