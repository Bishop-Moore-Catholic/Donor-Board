<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board â€“ Display (d3-cloud streaming)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root { --base-size: clamp(18px, 2.2vw, 36px); }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;

  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    svg.attr('viewBox', `0 0 \${W} \${H}`);
    redraw();
  }
  window.addEventListener('resize', resize);

  function load() { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function wordsFromDonors() {
    const baseSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;
    const list = load().slice().sort((a,b) => a.name.localeCompare(b.name, undefined, {sensitivity:'base'}));
    return list.map(d => ({ text: d.name, key: keyName(d.name), size: baseSizePx }));
  }

  // Store previous final positions so update tweens are smooth
  let prevPos = new Map(); // key -> {x,y,rotate,size}

  function redraw() {
    const CENTERX = W/2, CENTERY = H/2;
    const words = wordsFromDonors();

    const layer = svg.selectAll('g.words').data([null]).join('g').attr('class','words');

    // Streaming render: add each placed word immediately
    const streamed = new Set();

    const cloud = d3.layout.cloud()
      .size([W, H])
      .words(words)
      .padding(4)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0)
      .timeInterval(10)
      .on('word', d => {
        const k = keyName(d.text);
        if (streamed.has(k)) return;
        streamed.add(k);
        const pos = { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size };

        // If text node exists (from before), tween towards new streaming position; else create then fade in
        const sel = layer.selectAll('text.word').filter(n => n && n.text === d.text);
        if (!sel.size()) {
          layer.append('text')
            .attr('class', 'word')
            .style('font-family', 'system-ui, sans-serif')
            .text(d.text)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .style('opacity', 0)
            .attr('font-size', prevPos.get(k)?.size || d.size)
            .attr('transform', () => {
              const p = prevPos.get(k);
              const x0 = p ? p.x : CENTERX, y0 = p ? p.y : CENTERY, r0 = p ? p.rotate : 0;
              return `translate(\${x0},\${y0}) rotate(\${r0})`;
            })
            .transition().duration(500)
            .style('opacity', 1)
            .attr('font-size', pos.size)
            .attr('transform', `translate(\${pos.x},\${pos.y}) rotate(\${pos.rotate})`);
        } else {
          sel.transition().duration(500)
            .attr('font-size', pos.size)
            .attr('transform', `translate(\${pos.x},\${pos.y}) rotate(\${pos.rotate})`);
        }
      })
      .on('end', placed => {
        // Final gentle reconcile (move anything that needs a small nudge)
        const nextPos = new Map();
        placed.forEach(d => nextPos.set(keyName(d.text),
          { x: d.x + CENTERX, y: d.y + CENTERY, rotate: d.rotate || 0, size: d.size }));

        const sel = layer.selectAll('text.word').data(placed, d => d.text);

        // EXIT any that disappeared
        sel.exit()
          .transition().duration(400).style('opacity', 0).remove();

        // ENTER any that somehow weren't streamed (edge cases)
        const enter = sel.enter().append('text')
          .attr('class', 'word')
          .style('font-family', 'system-ui, sans-serif')
          .text(d => d.text)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .style('opacity', 0)
          .attr('font-size', d => (prevPos.get(keyName(d.text))?.size || d.size))
          .attr('transform', () => {
            const p = prevPos.get(keyName(d.text));
            const x0 = p ? p.x : CENTERX, y0 = p ? p.y : CENTERY, r0 = p ? p.rotate : 0;
            return `translate(\${x0},\${y0}) rotate(\${r0})`;
          });

        enter.merge(sel)
          .transition().duration(700)
          .style('opacity', 1)
          .attr('font-size', d => d.size)
          .attr('transform', d => {
            const p = nextPos.get(keyName(d.text));
            return `translate(\${p.x},\${p.y}) rotate(\${p.rotate})`;
          });

        prevPos = nextPos;
      });

    cloud.start();
  }

  function fullRender() { prevPos.clear(); redraw(); }

  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) redraw();
    else if (msg.type === 'reset') {
      svg.selectAll('*').remove();
      fullRender();
    }
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) redraw(); });

  // boot
  resize();
  fullRender();
})();
</script>
</body>
</html>