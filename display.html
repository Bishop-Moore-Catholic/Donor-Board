<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Donor Board – Display (d3-cloud)</title>
<link rel="icon" href="assets/favicon.svg">
<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/d3-cloud/build/d3.layout.cloud.js"></script>
<style>
  :root {
    --base-size: clamp(18px, 2.2vw, 36px); /* uniform final size */
    --in-scale: 2.1;                       /* pop-in scale */
    --gap: 12px;
  }
  html, body { height:100%; margin:0; background:#fafafa; color:#111; font-family: system-ui, sans-serif; overflow:hidden; }
  header { padding:16px 20px 8px; font-weight:600; letter-spacing:.5px; }
  #stage { position: relative; width: 100vw; height: calc(100vh - 48px); }
  svg { width:100%; height:100%; display:block; }
  .word { font-size: var(--base-size); fill:#111; dominant-baseline: middle; text-anchor: middle; }
  .word.new { transform-origin: center center; transform-box: fill-box; animation: pop 3.6s ease-out both; }
  @keyframes pop {
    0% { transform: scale(var(--in-scale)); opacity: 0; }
    10% { opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }
  /* 300x300 centerpiece placeholder, above the SVG but click-through */
  #centerpiece {
    position:absolute; left:50%; top:50%;
    width:300px; height:300px; margin-left:-150px; margin-top:-150px;
    display:grid; place-items:center;
    pointer-events:none;
  }
  #centerpiece img { width:300px; height:300px; object-fit:contain; border-radius:10px; }
</style>
</head>
<body>
<header>Thank you to our generous donors</header>
<div id="stage">
  <svg id="cloud" aria-label="Donor word cloud"></svg>
  <div id="centerpiece">
    <img id="centerImage" alt="Centerpiece 300×300" src="data:image/svg+xml;utf8,<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' width='300' height='300' viewBox='0 0 300 300'><rect width='300' height='300' fill='%23f5f5f5'/><rect x='1.5' y='1.5' width='297' height='297' fill='none' stroke='%23cccccc' stroke-width='3' stroke-dasharray='10 8'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-family='system-ui, sans-serif' font-size='18' fill='%23999'>300×300 Placeholder</text></svg>" />
  </div>
</div>

<script>
(() => {
  const KEY = 'donorList.v1';
  const CH = new BroadcastChannel('donors');
  const svg = d3.select('#cloud');
  const stage = document.getElementById('stage');
  let W = stage.clientWidth, H = stage.clientHeight;
  const CENTER = { x: W/2, y: H/2 };
  const CENTER_RECT = { x: CENTER.x - 150, y: CENTER.y - 150, w: 300, h: 300 };

  const present = new Map(); // nameKey -> true

  function load() {
    try { return JSON.parse(localStorage.getItem(KEY)) || []; }
    catch { return []; }
  }
  const normalizeName = s => s.normalize('NFKC').replace(/\s+/g,' ').trim();
  const keyName = s => normalizeName(s).toLowerCase();

  function resize(){
    W = stage.clientWidth; H = stage.clientHeight;
    svg.attr('viewBox', `0 0 ${W} ${H}`);
  }
  window.addEventListener('resize', () => { resize(); layout(); });

  function inCenter(x, y, w, h) {
    const r = CENTER_RECT;
    return !(x + w/2 < r.x || x - w/2 > r.x + r.w || y + h/2 < r.y || y - h/2 > r.y + r.h) ;
  }

  function nudgeOutOfCenter(word) {
    // push any word whose bbox overlaps the center rect outward along its vector from center
    const r = CENTER_RECT;
    const dirX = word.x - CENTER.x;
    const dirY = word.y - CENTER.y;
    const len = Math.max(1, Math.hypot(dirX, dirY));
    const ux = dirX / len, uy = dirY / len;
    let x = word.x, y = word.y;
    const halfW = word.width/2, halfH = word.height/2;

    let safety = 0;
    while (inCenter(x, y, word.width, word.height) && safety < 600) {
      x += ux * 6; y += uy * 6;
      safety++;
    }
    word.x = x; word.y = y;
  }

  function layout(newNameSet = new Set()) {
    const list = load();
    const names = list.map(d => d.name);
    // Use equal sizes so the end state is uniform
    const baseSizePx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--base-size')) || 28;

    // Build words array for d3-cloud
    const words = names.map(n => ({ text: n, size: baseSizePx }));

    // d3-cloud layout
    const cloud = d3.layout.cloud()
      .size([W, H])
      .words(words)
      .padding(4)
      .font('system-ui, sans-serif')
      .fontSize(d => d.size)
      .rotate(() => 0) // keep level for readability
      .spiral('archimedean')
      .on('end', draw);

    cloud.start();

    function draw(wds) {
      // Estimate text bbox width/height for centering logic (approx via canvas-measured by d3-cloud: d.x,d.y are centers)
      // d3-cloud gives: x, y (center), and has sprite/bbox dims via d.width/d.height if built with canvas sprite.
      // Some builds expose width/height; if not, approximate with size * char count factor.
      wds.forEach(d => {
        if (!('width' in d) || !('height' in d)) {
          const approxW = d.text.length * d.size * 0.6;
          const approxH = d.size * 1.2;
          d.width = approxW; d.height = approxH;
        }
        // Avoid the center 300x300 by nudging
        if (inCenter(d.x, d.y, d.width, d.height)) nudgeOutOfCenter(d);
      });

      // DATA JOIN
      const g = svg.selectAll('g.words').data([null]);
      g.enter().append('g').attr('class','words');
      const layer = svg.select('g.words');

      const sel = layer.selectAll('text.word').data(wds, d => d.text);

      // EXIT
      sel.exit().remove();

      // ENTER
      const enter = sel.enter().append('text')
        .attr('class', d => 'word' + (newNameSet.has(keyName(d.text)) ? ' new' : ''))
        .style('font-family', 'system-ui, sans-serif')
        .text(d => d.text)
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .attr('transform', d => `translate(${CENTER.x},${CENTER.y})`)
        .style('opacity', 0);

      // ENTER + UPDATE
      enter.merge(sel)
        .transition()
        .duration(1200)
        .attr('transform', d => `translate(${d.x + W/2},${d.y + H/2})`)
        .style('opacity', 1);
    }
  }

  function fullRender() {
    resize();
    present.clear();
    const list = load();
    for (const d of list) present.set(keyName(d.name), true);
    layout(); // no special "new" animations on initial load
  }

  function addNew(donors) {
    const newSet = new Set(donors.map(d => keyName(d.name)));
    // Re-layout using the "new" set so those nodes get the .new class (pop animation)
    layout(newSet);
    // track present
    donors.forEach(d => present.set(keyName(d.name), true));
  }

  // BroadcastChannel listeners
  CH.onmessage = (ev) => {
    const msg = ev.data || {};
    if (msg.type === 'added' && Array.isArray(msg.donors)) addNew(msg.donors);
    else if (msg.type === 'reset') fullRender();
  };

  window.addEventListener('storage', (e) => { if (e.key === KEY) fullRender(); });

  // Initial render
  fullRender();

  // Optional ?img= URL parameter
  const params = new URLSearchParams(location.search);
  const img = params.get('img');
  if (img) document.getElementById('centerImage').src = img;
})();
</script>
</body>
</html>
